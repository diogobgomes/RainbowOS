/**
 * @file apic.hpp
 * @author Diogo Gomes (dbarrosgomes@gmail.com)
 * @brief Definitions for dealing with the APIC
 * @version 0.1
 * @date 2025-02-12
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#pragma once

#include <stdint.h>
#include <stddef.h>
#include <kernelInternal/acpi.hpp>

namespace kernel::cpu
{
    static const uint8_t IA32_APIC_BASE =           0x1b;

    struct lapic_base_register
    {
        /* Reserved */
        uint8_t         reserved;

        /* Set if processor is bootstrap processor */
        uint8_t         bsp : 1;

        /* Reserved */
        uint8_t         reserved2 : 2;

        /* APIC global enable */
        uint8_t         apic_global_enable : 1;

        /* APIC adress. IMPORTANT: shift by 12*/
        uint32_t        address : 20;

        /* Reserved */
        uint32_t        reserved3;
    }__attribute__((packed));

    static_assert(sizeof(lapic_base_register)==8);

    struct spurious_interrupt_vector_register
    {
        /* Vector for the spurious interrupt generated by APIC */
        uint8_t         sp_vector;

        /* APIC enable flag */
        uint8_t         enable_flag : 1;

        /* Focus checking (leave it be) */
        uint8_t         focus_checking : 1;

        /* Reserved */
        uint32_t        reserved : 22;
    }__attribute__((packed));
    
    static_assert(sizeof(spurious_interrupt_vector_register)==4);

    enum class lapic_registers : uint32_t
    {
        LAPIC_ID = 0x020,
        LAPIC_VERSION = 0x030,
        TASK_PRIORITY = 0x080,
        ARBITRATION_PRIORITY = 0x090,
        PROCESSOR_PRIORITY = 0x0A0,
        EOI = 0x0B0,
        REMOTE_READ = 0x0C0,
        LOGICAL_DESTINATION = 0x0D0,
        DESTINATION_FORMAT = 0x0E0,
        SPURIOUS_INTERRUPT_VECTOR = 0x0F0,
        IN_SERVICE = 0x100, // Range 0x100 - 0x170
        TRIGGER_MODE = 0x180, // Range 0x180 - 0x1F0
        INTERRUPT_REQUEST = 0x200, // Range 0x200 - 0x270
        ERROR_STATUS = 0x280,
        LVT_CMCI = 0x2F0,
        INTERRUPT_COMMAND = 0x300, // Range 0x300 - 0x310
        LVT_TIMER = 0x320,
        LVT_THERMAL_SENSOR = 0x330,
        LVT_PERF_MONITORING = 0x340,
        LVT_LINT0 = 0x350,
        LVT_LINT1 = 0x360,
        LVT_ERROR = 0x370,
        INITIAL_COUNT = 0x380,
        CURRENT_COUNT = 0x390,
        DIVIDE_CONFIGURATION = 0x3E0
    };

    enum class ioapic_register_offset : uint32_t
    {
        IOREGSEL = 0x00,
        IOWIN = 0x10
    };

    enum class ioapic_mm_register : uint32_t
    {
        IOAPICID = 0x00,
        IOAPICVER = 0x01,
        IOAPICARB = 0x02,
        IOREDTBL = 0x03 // Range 0x03 - 0x3f
    };

    class io_apic
    {
    private:
        kernel::acpi::madt_entry_type1* _ptr;
    public:
        io_apic(kernel::acpi::acpi_madt* ptr);
        uint32_t read(ioapic_mm_register reg);
        void write(ioapic_mm_register reg, uint32_t value);
    };
    
    
    // TODO change lapic to class
    /**
     * @brief Checks if APIC is present
     * 
     * @return true If it is present
     * @return false If it's not present
     */
    bool checkApic(void);

    /**
     * @brief Get the address of the LAPIC base register
     * 
     * @return lapic_base_register* 
     */
    lapic_base_register* getAPICRegister();

    /**
     * @brief Enable the APIC
     * 
     */
    void enableAPIC();
    
} // namespace kernel::cpu

